# Пакет Signal

Пакет `signal` предоставляет обобщенные механизмы сигнализации для межпроцессного взаимодействия с использованием существующих структур данных из библиотеки types.

## Обзор

Этот пакет реализует системы сигнализации, которые позволяют отправлять сообщения от одного или нескольких источников одному или нескольким слушателям. Он предоставляет как обычные сигналы, так и буферизованные сигналы с различными характеристиками:

- **Signal**: Базовый сигнал, который транслирует сообщения всем подписчикам
- **BufferedSignal**: Сигнал с внутренним буфером, который хранит последние значения

## Особенности

- **Обобщенный**: Работает с любым типом `T`
- **Потокобезопасный**: Все операции защищены мьютексами
- **Гибкий**: Поддержка нескольких слушателей на один сигнал
- **Буферизованный**: Необязательная внутренняя буферизация с ограничениями по размеру
- **Управление ресурсами**: Правильная очистка с функциями отмены подписки

## Установка

```bash
go get types/signal
```

## Использование

### Базовый Signal

```go
package main

import (
    "fmt"
    "types/signal"
)

func main() {
    // Создание нового сигнала
    sig := signal.New[string]()
    
    // Подписка на сигнал
    ch, unsubscribe := sig.Subscribe(10) // размер буфера 10
    defer unsubscribe()
    
    // Отправка значения
    go sig.Emit("Hello, World!")
    
    // Получение значения
    msg := <-ch
    fmt.Println(msg) // Вывод: Hello, World!
}
```

### Буферизованный Signal

```go
package main

import (
    "fmt"
    "types/signal"
)

func main() {
    // Создание нового буферизованного сигнала с емкостью 5
    bufSig := signal.NewBuffered[int](5)
    
    // Подписка на сигнал
    ch, unsubscribe := bufSig.Subscribe(10)
    defer unsubscribe()
    
    // Отправка нескольких значений
    for i := 1; i <= 3; i++ {
        bufSig.Emit(i)
    }
    
    // Получение значений
    for i := 0; i < 3; i++ {
        val := <-ch
        fmt.Printf("Получено: %d\n", val)
    }
    
    // Проверка содержимого внутреннего буфера
    buffer := bufSig.GetBuffer()
    fmt.Printf("Внутренний буфер: %v\n", buffer)
}
```

### Несколько слушателей

```go
package main

import (
    "fmt"
    "time"
    "types/signal"
)

func main() {
    sig := signal.New[string]()
    
    // Создание нескольких слушателей
    ch1, unsub1 := sig.Subscribe(10)
    ch2, unsub2 := sig.Subscribe(10)
    defer unsub1()
    defer unsub2()
    
    // Прослушивание в отдельных горутинах
    go func() {
        msg := <-ch1
        fmt.Printf("Слушатель 1: %s\n", msg)
    }()
    
    go func() {
        msg := <-ch2
        fmt.Printf("Слушатель 2: %s\n", msg)
    }()
    
    // Отправка значения
    sig.Emit("Сообщение для трансляции")
    
    // Ожидание вывода
    time.Sleep(time.Millisecond * 100)
}
```

## API

### Signal[T]

- `New[T]()` - Создает новый экземпляр Signal
- `Subscribe(bufferSize int) (<-chan T, func())` - Подписывается на сигнал и возвращает канал и функцию отмены подписки
- `Emit(value T)` - Отправляет значение всем подписанным слушателям (неблокирующая операция)
- `EmitSync(value T)` - Отправляет значение всем подписанным слушателям (блокирующая операция до получения всеми)
- `Broadcast(value T)` - Отправляет значение всем подписанным слушателям параллельно

### BufferedSignal[T]

- `NewBuffered[T](bufSize int)` - Создает новый BufferedSignal с указанным размером буфера
- `Subscribe(bufferSize int) (<-chan T, func())` - Подписывается на сигнал
- `Emit(value T)` - Отправляет значение всем подписчикам и сохраняет во внутреннем буфере
- `EmitSync(value T)` - Отправляет значение синхронно и сохраняет во внутреннем буфере
- `Broadcast(value T)` - Отправляет значение параллельно и сохраняет во внутреннем буфере
- `GetBuffer() []T` - Возвращает копию внутреннего буфера
- `ClearBuffer()` - Очищает внутренний буфер

## Используемые структуры данных

Этот пакет использует существующие структуры данных из библиотеки types:

- `types/collections/queue` - Для внутренней буферизации в BufferedSignal
- `types/collections/set` - Для отслеживания активных слушателей
