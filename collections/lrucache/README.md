# LRUCache

Пакет `lrucache` предоставляет реализацию кэша с политикой LRU (Least Recently Used) - структуры данных для хранения ограниченного количества элементов с автоматическим удалением наименее недавно использованных при превышении емкости.

## Особенности

- **Политика LRU**: автоматически удаляет наименее недавно использованные элементы при превышении размера
- **O(1) сложность**: все операции (Get, Put, Remove) выполняются за константное время
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Обобщения**: поддержка любых типов ключей и значений через обобщения Go
- **Гибкий API**: расширенные методы для итерации, получения ключей/значений, изменения размера

## Основные методы

- `New[K comparable, V any](capacity int) *LRUCache[K, V]` - создает новый LRU кэш с заданной емкостью
- `Get(key K) (V, bool)` - получает значение по ключу, перемещая элемент в начало (MRU)
- `Put(key K, value V)` - добавляет или обновляет пару ключ-значение
- `Remove(key K) bool` - удаляет элемент по ключу
- `Peek(key K) (V, bool)` - получает значение без изменения порядка использования
- `Contains(key K) bool` - проверяет наличие ключа в кэше
- `Size() int` - возвращает текущее количество элементов
- `Capacity() int` - возвращает максимальную емкость кэша
- `IsEmpty() bool` - возвращает true если кэш пуст
- `Clear()` - удаляет все элементы из кэша
- `Resize(newCapacity int)` - изменяет емкость кэша (с вытеснением при необходимости)

## Методы итерации

- `Keys() []K` - возвращает все ключи в порядке LRU (наименее недавно использованные первыми)
- `Values() []V` - возвращает все значения в порядке LRU
- `ForEach(fn func(key K, value V))` - итерирует по всем парам в порядке LRU
- `ForEachMRU(fn func(key K, value V))` - итерирует по всем парам в порядке MRU (наиболее недавно использованные первыми)

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/lrucache"
)

func main() {
    // Создаем LRU кэш с емкостью 3
    cache := lrucache.New[string, int](3)
    
    // Добавляем элементы
    cache.Put("apple", 1)
    cache.Put("banana", 2) 
    cache.Put("cherry", 3)
    
    // Получаем элемент (становится наиболее недавно использованным)
    if val, ok := cache.Get("apple"); ok {
        fmt.Printf("Got apple: %d\n", val) // Got apple: 1
    }
    
    // Добавляем новый элемент - вытесняется наименее недавно использованный ("banana")
    cache.Put("date", 4)
    
    // Проверяем содержимое
    fmt.Println("Contains banana:", cache.Contains("banana")) // false
    fmt.Println("Contains cherry:", cache.Contains("cherry")) // true
    fmt.Println("Cache size:", cache.Size())                  // 3
    
    // Итерируем по элементам в порядке LRU (наименее недавно использованные первыми)
    fmt.Print("LRU order: ")
    cache.ForEach(func(key string, value int) {
        fmt.Printf("%s:%d ", key, value)
    })
    // Вывод: LRU order: cherry:3 date:4 apple:1
    
    // Получаем ключи
    keys := cache.Keys()
    fmt.Printf("\nKeys: %v\n", keys) // Keys: [cherry date apple]
}
```

## Применение

- **Кэширование**: хранение часто используемых данных с автоматической очисткой
- **Системы баз данных**: буферизация страниц и записей
- **Веб-серверы**: кэширование ответов и сессий
- **Алгоритмы**: реализация алгоритмов, требующих ограниченного хранилища с политикой вытеснения
- **Оптимизация памяти**: управление памятью в приложениях с ограниченными ресурсами

## Реализация

LRUCache использует комбинацию двусвязного списка и хеш-таблицы:
- **Хеш-таблица** обеспечивает O(1) доступ к элементам по ключу
- **Двусвязный список** поддерживает порядок использования (MRU в начале, LRU в конце)
- При каждом доступе к элементу он перемещается в начало списка (становится MRU)
- При превышении емкости удаляется последний элемент списка (LRU)

## Производительность

- **Память**: O(n) где n - количество элементов в кэше
- **Get**: O(1)
- **Put**: O(1)  
- **Remove**: O(1)
- **Peek**: O(1)
- **Итерация**: O(n)

## Особенности поведения

- **Get** перемещает элемент в начало (делает его MRU)
- **Peek** не изменяет порядок использования
- **Put** существующего ключа обновляет значение и делает элемент MRU
- **Resize** с уменьшением емкости вытесняет LRU элементы до достижения новой емкости
- Емкость всегда как минимум 1 (даже если передано 0 или отрицательное значение)