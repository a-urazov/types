# BitSet

Пакет `bitset` предоставляет реализацию битового множества (Bit Set) - структуры данных для эффективного хранения больших наборов неотрицательных целых чисел. BitSet использует битовую арифметику, где каждый бит представляет наличие или отсутствие соответствующего целого числа в множестве.

## Особенности

- **Эффективность по памяти**: 1 бит на элемент вместо 4-8 байт для обычных целых чисел
- **Быстрые побитовые операции**: AND, OR, XOR, NOT выполняются за O(n/64) времени
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Динамический размер**: автоматически расширяется при добавлении больших значений
- **Поддержка только неотрицательных целых**: отрицательные значения игнорируются

## Основные методы

- `New() *BitSet` - создает новое пустое битовое множество
- `WithCapacity(maxValue int) *BitSet` - создает битовое множество с начальной емкостью
- `Set(value int)` - добавляет значение в множество (игнорирует отрицательные значения)
- `Clear(value int)` - удаляет значение из множества
- `Get(value int) bool` - проверяет наличие значения в множестве
- `Size() int` - возвращает количество элементов в множестве
- `IsEmpty() bool` - возвращает true если множество пусто
- `ClearAll()` - удаляет все элементы из множества
- `ToSlice() []int` - возвращает срез всех значений в множестве
- `ForEach(action func(value int))` - итерирует по всем значениям в множестве
- `Min() int` - возвращает минимальное значение в множестве (-1 если пусто)
- `Max() int` - возвращает максимальное значение в множестве (-1 если пусто)
- `NextSetBit(fromIndex int) int` - возвращает следующий установленный бит после заданного индекса

## Побитовые операции

- `Union(other *BitSet)` - объединение множеств (A ∪ B)
- `Intersection(other *BitSet)` - пересечение множеств (A ∩ B)  
- `Difference(other *BitSet)` - разность множеств (A \ B)
- `SymmetricDifference(other *BitSet)` - симметрическая разность (A ⊕ B)
- `Clone() *BitSet` - создает глубокую копию множества
- `Equals(other *BitSet) bool` - проверяет равенство двух множеств

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/bitset"
)

func main() {
    // Создаем новое битовое множество
    bs := bitset.New()
    
    // Добавляем значения
    bs.Set(10)
    bs.Set(20)
    bs.Set(30)
    bs.Set(1000) // Автоматически расширяет внутренний массив
    
    // Проверяем наличие значений
    fmt.Println("Contains 10:", bs.Get(10))   // true
    fmt.Println("Contains 15:", bs.Get(15))   // false
    
    // Получаем статистику
    fmt.Println("Size:", bs.Size())           // 4
    fmt.Println("Min:", bs.Min())             // 10
    fmt.Println("Max:", bs.Max())             // 1000
    
    // Итерируем по всем значениям
    fmt.Print("All values: ")
    bs.ForEach(func(value int) {
        fmt.Printf("%d ", value)
    })
    // Вывод: All values: 10 20 30 1000
    
    // Побитовые операции
    bs2 := bitset.New()
    bs2.Set(20)
    bs2.Set(40)
    bs2.Set(50)
    
    // Объединение
    union := bs.Clone()
    union.Union(bs2)
    fmt.Println("\nUnion size:", union.Size()) // 6 (10,20,30,40,50,1000)
    
    // Пересечение  
    intersection := bs.Clone()
    intersection.Intersection(bs2)
    fmt.Println("Intersection size:", intersection.Size()) // 1 (только 20)
}
```

## Применение

- **Фильтрация и индексация**: эффективное хранение флагов наличия элементов
- **Алгоритмы обработки множеств**: когда нужно выполнять множество операций над большими наборами целых чисел
- **Сжатие данных**: представление разреженных наборов данных
- **Криптография и хеширование**: работа с битовыми масками
- **Системы управления доступом**: хранение прав доступа как битовых флагов
- **Обработка сигналов**: представление временных меток или событий

## Производительность

- **Память**: O(n/8) байт для хранения n битов
- **Set/Get/Clear**: O(1) амортизированное время
- **Size**: O(n/64) время (подсчет установленных битов)
- **Побитовые операции**: O(max(m,n)/64) где m,n - размеры операндов
- **ToSlice/ForEach**: O(k) где k - количество установленных битов

## Ограничения

- Поддерживает только неотрицательные целые числа
- Максимальное значение ограничено доступной памятью
- Не подходит для хранения произвольных типов данных (только целые числа)