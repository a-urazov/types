# Отсортированное множество

Пакет `sortedset` предоставляет реализацию отсортированного множества (Sorted Set) - структуры данных, которая хранит уникальные элементы в отсортированном порядке. SortedSet основан на красно-черном дереве, что обеспечивает гарантированную O(log n) сложность для операций вставки, удаления и поиска.

## Особенности

- **Уникальные элементы**: каждый элемент может присутствовать в множестве только один раз
- **Отсортированный порядок**: элементы всегда хранятся и итерируются в отсортированном порядке
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Обобщения**: поддержка любого типа данных через обобщения Go
- **Расширенные операции**: Ceiling, Floor, First, Last для эффективной работы с упорядоченными данными

## Основные методы

- `New(compare func(a, b T) bool) *SortedSet[T]` - создает новое отсортированное множество с функцией сравнения
- `Add(item T) bool` - добавляет элемент в множество, возвращает false если элемент уже существует
- `Remove(item T) bool` - удаляет элемент из множества, возвращает false если элемент не найден
- `Contains(item T) bool` - проверяет наличие элемента в множестве
- `Size() int` - возвращает количество элементов в множестве
- `IsEmpty() bool` - возвращает true если множество пусто
- `Clear()` - удаляет все элементы из множества
- `ToSlice() []T` - возвращает срез всех элементов в отсортированном порядке
- `ForEach(action func(item T))` - итерирует по всем элементам в отсортированном порядке
- `First() (T, bool)` - возвращает наименьший элемент в множестве
- `Last() (T, bool)` - возвращает наибольший элемент в множестве
- `Ceiling(item T) (T, bool)` - возвращает наименьший элемент >= заданного значения
- `Floor(item T) (T, bool)` - возвращает наибольший элемент <= заданного значения

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/sortedset"
)

func main() {
    // Создаем отсортированное множество для целых чисел
    set := sortedset.New(func(a, b int) bool { return a < b })

    // Добавляем элементы (в любом порядке)
    set.Add(5)
    set.Add(1)
    set.Add(3)
    set.Add(7)
    set.Add(3) // Дубликат, не будет добавлен

    // Итерируем по элементам в отсортированном порядке
    fmt.Print("Elements: ")
    set.ForEach(func(item int) {
        fmt.Printf("%d ", item)
    })
    // Вывод: Elements: 1 3 5 7

    // Получаем первый и последний элементы
    if first, ok := set.First(); ok {
        fmt.Printf("\nFirst: %d", first) // First: 1
    }
    if last, ok := set.Last(); ok {
        fmt.Printf("\nLast: %d", last) // Last: 7
    }

    // Используем Ceiling и Floor
    if ceil, ok := set.Ceiling(4); ok {
        fmt.Printf("\nCeiling(4): %d", ceil) // Ceiling(4): 5
    }
    if floor, ok := set.Floor(4); ok {
        fmt.Printf("\nFloor(4): %d", floor) // Floor(4): 3
    }

    fmt.Printf("\nSize: %d", set.Size()) // Size: 4
}
```

## Применение

- Реализация упорядоченных индексов в базах данных
- Алгоритмы, требующие поддержания отсортированного набора уникальных значений
- Системы ранжирования и сортировки
- Математические вычисления с множествами
- Кэширование с упорядоченным доступом

## Производительность

- **Вставка (Add)**: O(log n)
- **Удаление (Remove)**: O(log n)
- **Поиск (Contains)**: O(log n)
- **Итерация (ForEach)**: O(n)
- **Ceiling/Floor**: O(log n)
- **Память**: O(n)
