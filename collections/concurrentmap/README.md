# ConcurrentMap

Пакет `concurrentmap` предоставляет реализацию потокобезопасной хеш-таблицы (мапа) с оптимизированной производительностью через разделение блокировок (sharding). Это позволяет нескольким горутинам одновременно читать и писать в разные сегменты мапы, что значительно повышает производительность при высокой нагрузке.

## Особенности

- **Потокобезопасность**: все операции безопасны для использования из нескольких горутин
- **Разделение блокировок**: разные сегменты мапы блокируются независимо, что повышает параллелизм
- **Обобщения**: поддержка любых сравнимых типов ключей и любых типов значений
- **Гибкий API**: полный набор операций: Set, Get, Delete, Contains, Update и другие
- **Масштабируемость**: можно изменять количество сегментов для оптимизации под конкретную нагрузку

## Основные методы

- `New[K comparable, V any]() *ConcurrentMap[K, V]` - создает новую мапу с количеством сегментов по умолчанию
- `NewWithShardCount[K comparable, V any](shardCount int) *ConcurrentMap[K, V]` - создает мапу с указанным количеством сегментов
- `Set(key K, value V)` - добавляет или обновляет пару ключ-значение
- `Get(key K) (V, bool)` - получает значение по ключу
- `Delete(key K) bool` - удаляет пару ключ-значение
- `Contains(key K) bool` - проверяет наличие ключа
- `TrySet(key K, value V) bool` - добавляет значение только если ключ не существует
- `GetOrSet(key K, value V) (V, bool)` - возвращает значение, добавляя его при необходимости
- `Update(key K, updateFn func(V) V) bool` - обновляет значение с помощью функции
- `Len() int` - возвращает общее количество элементов
- `IsEmpty() bool` - проверяет, пуста ли мапа
- `Clear()` - удаляет все элементы
- `Size() int` - возвращает количество сегментов
- `ResizeShards(newShardCount int)` - изменяет количество сегментов
- `Keys() []K` - возвращает все ключи
- `Values() []V` - возвращает все значения
- `Items() map[K]V` - возвращает копию всей мапы
- `ForEach(fn func(key K, value V))` - итерирует по всем парам ключ-значение

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/concurrentmap"
)

func main() {
    // Создаем новую потокобезопасную мапу
    cm := concurrentmap.New[string, int]()
    
    // Добавляем элементы
    cm.Set("apple", 5)
    cm.Set("banana", 3)
    cm.Set("cherry", 8)
    
    // Получаем значения
    if value, ok := cm.Get("apple"); ok {
        fmt.Printf("Apple count: %d\n", value) // Apple count: 5
    }
    
    // Проверяем наличие ключа
    if cm.Contains("banana") {
        fmt.Println("Banana exists in map")
    }
    
    // Обновляем значение
    cm.Update("apple", func(v int) int {
        return v + 2 // увеличиваем на 2
    })
    
    // Итерируем по элементам
    cm.ForEach(func(key string, value int) {
        fmt.Printf("%s: %d\n", key, value)
    })
    
    // Удаляем элемент
    if cm.Delete("cherry") {
        fmt.Println("Cherry removed")
    }
    
    // Попробовать установить значение, только если ключ не существует
    if cm.TrySet("date", 1) {
        fmt.Println("Date added")
    }
    
    fmt.Printf("Total items: %d\n", cm.Len())
}
```

## Алгоритм разделения блокировок (Sharding)

ConcurrentMap делит хеш-таблицу на несколько сегментов (шардов), каждый из которых защищен отдельной блокировкой. Ключ определяет, в каком сегменте будет храниться значение, с помощью хеширования. Это позволяет нескольким горутинам одновременно работать с разными сегментами, увеличивая параллелизм.

Количество сегментов по умолчанию - 32, но его можно настроить с помощью `NewWithShardCount()`.

## Применение

- **Кэширование**: хранение часто используемых данных с безопасным доступом из нескольких горутин
- **Счетчики**: подсчет метрик, статистики в многопоточной среде
- **Сессии**: хранение данных сессий в веб-приложениях
- **Координаторы**: хранение состояния распределенных систем
- **Базы данных**: внутренние структуры данных для систем хранения

## Производительность

- **Память**: O(n) где n - количество элементов
- **Get/Set/Delete**: O(1) амортизированное время
- **Конкурентность**: производительность масштабируется с увеличением количества сегментов
- **Количество сегментов**: влияет на баланс между параллелизмом и накладными расходами

## Особенности поведения

- **Порядок итерации**: не гарантируется порядок при использовании `ForEach`, `Keys`, `Values`
- **Атомарность операций**: каждая операция (Set, Get и т.д.) атомарна, но комбинации операций не атомарны
- **Безопасность**: все операции потокобезопасны, но `ResizeShards` может быть дорогой операцией
- **Хеширование**: использует встроенный хеш для встроенных типов, иначе строковое представление