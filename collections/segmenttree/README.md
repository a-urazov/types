# Дерево отрезков

Пакет `segmenttree` предоставляет реализацию дерева отрезков (Segment Tree) - структуры данных, которая позволяет эффективно выполнять запросы на диапазонах массива (например, сумма, минимум, максимум) и обновлять отдельные элементы.

## Особенности

- **Эффективные диапазонные запросы**: O(log n) для запросов на диапазонах
- **Быстрые точечные обновления**: O(log n) для обновления отдельных элементов
- **Гибкость**: поддержка любой ассоциативной функции (сумма, минимум, максимум, произведение и т.д.)
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Обобщения**: поддержка любых типов данных через обобщения Go

## Основные методы

- `New[T any](data []T, mergeFn func(a, b T) T) *SegmentTree[T]` - создает новое дерево отрезков
- `Query(left, right int) (T, bool)` - выполняет запрос на диапазоне [left, right]
- `Update(index int, value T) bool` - обновляет значение элемента по индексу
- `Get(index int) (T, bool)` - получает значение элемента по индексу
- `Size() int` - возвращает количество элементов
- `IsEmpty() bool` - возвращает true если дерево пусто
- `Clear()` - удаляет все элементы
- `Resize(newSize int)` - изменяет размер дерева
- `ToSlice() []T` - возвращает копию исходного массива
- `ForEach(fn func(index int, value T))` - итерирует по всем элементам

## Вспомогательные конструкторы

- `Sum(data []int) *SegmentTree[int]` - создает дерево отрезков для запросов суммы
- `Min(data []int) *SegmentTree[int]` - создает дерево отрезков для запросов минимума
- `Max(data []int) *SegmentTree[int]` - создает дерево отрезков для запросов максимума

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/segmenttree"
)

func main() {
    // Создаем дерево отрезков для запросов суммы
    data := []int{1, 3, 5, 7, 9, 11}
    st := segmenttree.Sum(data)

    // Выполняем запросы на диапазонах
    if sum, ok := st.Query(1, 4); ok {
        fmt.Printf("Sum of range [1,4]: %d\n", sum) // 3 + 5 + 7 + 9 = 24
    }

    // Обновляем элемент
    st.Update(2, 10) // data becomes [1, 3, 10, 7, 9, 11]

    // Выполняем запрос снова
    if sum, ok := st.Query(1, 4); ok {
        fmt.Printf("New sum of range [1,4]: %d\n", sum) // 3 + 10 + 7 + 9 = 29
    }

    // Создаем дерево для запросов минимума
    minSt := segmenttree.Min([]int{5, 2, 8, 1, 9, 3})
    if min, ok := minSt.Query(0, 5); ok {
        fmt.Printf("Minimum in range [0,5]: %d\n", min) // 1
    }
}
```

## Применение

- **Обработка массивов**: быстрые запросы на диапазонах и обновления
- **Вычислительная геометрия**: задачи на пересечение отрезков, поиск ближайших точек
- **Динамическое программирование**: оптимизация некоторых DP-решений
- **Финансовый анализ**: анализ временных рядов, скользящие средние
- **Компьютерные игры**: обработка событий в игровом мире, физические симуляции

## Реализация

Дерево отрезков - это двоичное дерево, где каждый узел представляет собой результат применения функции `mergeFn` к некоторому диапазону исходного массива.
- **Листья** дерева соответствуют элементам исходного массива
- **Внутренние узлы** хранят результат объединения своих дочерних узлов
- **Корень** представляет результат для всего массива

## Производительность

- **Память**: O(n) где n - количество элементов
- **Построение**: O(n)
- **Query**: O(log n)
- **Update**: O(log n)

## Особенности поведения

- **Ассоциативность**: функция `mergeFn` должна быть ассоциативной (например, `(a+b)+c = a+(b+c)`)
- **Копирование данных**: конструктор `New` создает копию исходного массива, так что изменения в исходном массиве не влияют на дерево
- **Нулевые значения**: при запросах на диапазонах, где один из дочерних узлов не пересекается с диапазоном, используется нулевое значение типа `T`
- **Потокобезопасность**: все операции блокируют всю структуру данных, обеспечивая согласованность
