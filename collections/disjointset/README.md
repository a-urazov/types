# Система непересекающихся множеств

Пакет `disjointset` предоставляет реализацию системы непересекающихся множеств (Disjoint Set), также известной как Union-Find или структура данных для поиска связных компонентов. Эта структура данных эффективно отслеживает набор элементов, разделенных на непересекающиеся подмножества, и поддерживает операции объединения множеств и поиска представителя множества.

## Особенности

- **Эффективные операции**: почти константная амортизированная сложность благодаря path compression и union by rank
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Обобщения**: поддержка любых сравнимых типов через обобщения Go
- **Автоматическое создание элементов**: операции Union автоматически создают несуществующие элементы
- **Расширенный API**: методы для получения информации о множествах и итерации

## Основные методы

- `New[T comparable]() *DisjointSet[T]` - создает новую пустую систему непересекающихся множеств
- `MakeSet(element T)` - создает новое множество, содержащее только заданный элемент
- `Find(element T) (T, bool)` - находит представителя (корень) множества, содержащего элемент
- `Union(element1, element2 T) bool` - объединяет множества, содержащие два элемента
- `Connected(element1, element2 T) bool` - проверяет, находятся ли два элемента в одном множестве
- `Size() int` - возвращает общее количество элементов
- `IsEmpty() bool` - возвращает true если структура данных пуста
- `Clear()` - удаляет все элементы
- `SetCount() int` - возвращает количество непересекающихся множеств
- `Elements() []T` - возвращает срез всех элементов
- `Sets() [][]T` - возвращает срез всех множеств
- `ForEachSet(fn func(elements []T))` - итерирует по всем множествам

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/disjointset"
)

func main() {
    // Создаем новую систему непересекающихся множеств
    ds := disjointset.New[string]()

    // Добавляем элементы
    ds.MakeSet("apple")
    ds.MakeSet("banana")
    ds.MakeSet("cherry")
    ds.MakeSet("date")

    // Проверяем, что элементы в разных множествах
    fmt.Println("Apple and banana connected:", ds.Connected("apple", "banana")) // false

    // Объединяем множества
    ds.Union("apple", "banana")
    ds.Union("cherry", "date")

    // Проверяем соединения
    fmt.Println("Apple and banana connected:", ds.Connected("apple", "banana")) // true
    fmt.Println("Apple and cherry connected:", ds.Connected("apple", "cherry")) // false

    // Находим представителей
    if root, ok := ds.Find("apple"); ok {
        fmt.Printf("Root of apple: %s\n", root)
    }

    // Получаем информацию о множествах
    fmt.Printf("Total elements: %d\n", ds.Size())        // 4
    fmt.Printf("Number of sets: %d\n", ds.SetCount())    // 2

    // Итерируем по всем множествам
    fmt.Println("All sets:")
    ds.ForEachSet(func(elements []string) {
        fmt.Printf("  %v\n", elements)
    })
    // Вывод может быть:
    //   [apple banana]
    //   [cherry date]
}
```

## Алгоритмические оптимизации

### Path Compression (Сжатие пути)
Когда выполняется операция Find, все пройденные узлы напрямую связываются с корнем. Это уменьшает высоту дерева и ускоряет будущие операции.

### Union by Rank (Объединение по рангу)
При объединении двух деревьев меньшее дерево (по рангу/высоте) прикрепляется к корню большего дерева. Это предотвращает чрезмерный рост высоты дерева.

Благодаря этим оптимизациям, амортизированная сложность операций составляет O(α(n)), где α - обратная функция Аккермана, которая фактически является константой для всех практических значений n.

## Применение

- **Алгоритмы на графах**: поиск связных компонентов, алгоритм Крускала для минимального остовного дерева
- **Обработка изображений**: сегментация изображений, поиск связных областей
- **Динамическая связность**: отслеживание соединений в динамически изменяющемся графе
- **Компьютерные игры**: системы территорий, кланов или альянсов
- **Сетевые алгоритмы**: отслеживание групп устройств или пользователей

## Производительность

- **Память**: O(n) где n - количество элементов
- **MakeSet**: O(1)
- **Find**: O(α(n)) амортизированное время
- **Union**: O(α(n)) амортизированное время
- **Connected**: O(α(n)) амортизированное время
- **Sets/SetCount**: O(n) время (требует обхода всех элементов)

## Особенности поведения

- **Автоматическое создание**: операции Union автоматически создают несуществующие элементы
- **Идемпотентность**: повторные вызовы MakeSet для существующего элемента игнорируются
- **Стабильность представителей**: после объединения представитель одного из исходных множеств становится представителем объединенного множества
- **Потокобезопасность**: все операции блокируют всю структуру данных, обеспечивая согласованность
