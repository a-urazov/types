# Фильтр Блума

Пакет `bloomfilter` предоставляет реализацию фильтра Блума (Bloom Filter) - вероятностной структуры данных для проверки принадлежности элемента множеству. Bloom Filter может возвращать ложноположительные результаты (элемент может быть в множестве), но никогда не возвращает ложноотрицательные (если элемент точно отсутствует).

## Особенности

- **Вероятностная природа**: гарантирует отсутствие ложноотрицательных результатов, но допускает ложноположительные
- **Эффективность по памяти**: использует значительно меньше памяти по сравнению с хранением самих элементов
- **Постоянное время операций**: добавление и проверка выполняются за O(k) где k - количество хеш-функций
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Неразрушимость**: элементы нельзя удалить из фильтра (только очистить весь фильтр)

## Основные методы

- `New(expectedElements int, falsePositiveRate float64) *BloomFilter` - создает новый фильтр с заданными параметрами
- `WithSize(bitArraySize uint64, numHashes int) *BloomFilter` - создает фильтр с явными размерами
- `Add(data []byte)` - добавляет элемент в фильтр
- `MightContain(data []byte) bool` - проверяет, может ли элемент быть в фильтре
- `Size() int` - возвращает приблизительное количество элементов в фильтре
- `IsEmpty() bool` - возвращает true если фильтр пуст
- `Clear()` - удаляет все элементы из фильтра
- `Clone() *BloomFilter` - создает глубокую копию фильтра
- `Merge(other *BloomFilter) error` - объединяет два совместимых фильтра
- `FalsePositiveRate() float64` - возвращает текущую оценку вероятности ложных срабатываний
- `Capacity() uint64` - возвращает общее количество битов в фильтре
- `NumHashes() int` - возвращает количество используемых хеш-функций

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/bloomfilter"
)

func main() {
    // Создаем BloomFilter для 1000 элементов с 1% вероятностью ложных срабатываний
    bf := bloomfilter.New(1000, 0.01)

    // Добавляем элементы
    bf.Add([]byte("apple"))
    bf.Add([]byte("banana"))
    bf.Add([]byte("cherry"))

    // Проверяем наличие элементов
    fmt.Println("Contains 'apple':", bf.MightContain([]byte("apple")))     // true
    fmt.Println("Contains 'grape':", bf.MightContain([]byte("grape")))     // false или true (ложное срабатывание)

    // Получаем статистику
    fmt.Printf("Approximate size: %d\n", bf.Size())
    fmt.Printf("False positive rate: %.2f%%\n", bf.FalsePositiveRate()*100)

    // Объединение фильтров
    bf2 := bloomfilter.New(1000, 0.01)
    bf2.Add([]byte("date"))
    bf2.Add([]byte("elderberry"))

    err := bf.Merge(bf2)
    if err != nil {
        fmt.Printf("Error merging filters: %v\n", err)
    }

    // Теперь bf содержит все элементы из обоих фильтров
    fmt.Println("After merge - contains 'date':", bf.MightContain([]byte("date")))
}
```

## Математические основы

Фильтр Блума использует следующие формулы для оптимальных параметров:

- **Размер битового массива**: `m = -n * ln(p) / (ln(2))²`
  - где `n` - ожидаемое количество элементов
  - где `p` - желаемая вероятность ложных срабатываний

- **Количество хеш-функций**: `k = (m/n) * ln(2)`

- **Вероятность ложных срабатываний**: `(1 - e^(-k*n/m))^k`

## Применение

- **Системы кэширования**: быстрая проверка наличия элемента перед обращением к медленному хранилищу
- **Базы данных**: предварительная фильтрация запросов к индексам
- **Сетевые приложения**: фильтрация спама, дедупликация пакетов
- **Биоинформатика**: поиск последовательностей в больших наборах данных
- **Распределенные системы**: уменьшение сетевого трафика за счет локальной фильтрации
- **Браузеры**: проверка посещенных URL без хранения полного списка

## Преимущества и недостатки

### Преимущества:
- Очень низкое потребление памяти
- Постоянное время выполнения операций
- Отсутствие ложноотрицательных результатов
- Простота реализации и использования

### Недостатки:
- Возможны ложноположительные результаты
- Нельзя удалить отдельные элементы
- Требуется знание ожидаемого количества элементов для оптимальной настройки
- При переполнении эффективность резко падает

## Производительность

- **Память**: O(m) бит, где m - размер битового массива
- **Add**: O(k) где k - количество хеш-функций
- **MightContain**: O(k) где k - количество хеш-функций
- **Merge**: O(m/64) где m - размер битового массива

## Настройка параметров

Для большинства применений рекомендуется использовать конструктор `New()` с оценкой ожидаемого количества элементов и приемлемой вероятностью ложных срабатываний. Типичные значения:

- **1% ложных срабатываний**: `falsePositiveRate = 0.01`
- **0.1% ложных срабатываний**: `falsePositiveRate = 0.001`
- **5% ложных срабатываний**: `falsePositiveRate = 0.05`

Чем ниже вероятность ложных срабатываний, тем больше памяти требуется.
