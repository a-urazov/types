# CircularList

Пакет `circularlist` предоставляет реализацию циклического двусвязного списка - структуры данных, в которой последний элемент ссылается на первый, образуя кольцо. Это позволяет эффективно выполнять операции вставки и удаления в любом месте списка, а также обеспечивает циклическую навигацию по элементам.

## Особенности

- **Циклическая структура**: последний элемент ссылается на первый, образуя кольцо
- **Двусвязность**: каждый элемент содержит ссылки на предыдущий и следующий элементы
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Обобщения**: поддержка любых типов данных через обобщения Go
- **Эффективная навигация**: возможность перемещаться по списку в обоих направлениях
- **Поддержка вращения**: операции для циклического сдвига элементов

## Основные методы

- `New[T any]() *CircularList[T]` - создает новый пустой циклический список
- `Add(value T)` - добавляет элемент в конец списка
- `AddAt(index int, value T) bool` - добавляет элемент по указанному индексу
- `Get(index int) (T, bool)` - получает элемент по индексу
- `Set(index int, value T) bool` - устанавливает значение элемента по индексу
- `Remove(value T) bool` - удаляет первое вхождение элемента
- `RemoveAt(index int) bool` - удаляет элемент по индексу
- `Size() int` - возвращает количество элементов
- `IsEmpty() bool` - проверяет, пуст ли список
- `Clear()` - удаляет все элементы
- `Contains(value T) bool` - проверяет наличие элемента
- `IndexOf(value T) int` - возвращает индекс первого вхождения элемента
- `ToSlice() []T` - возвращает срез всех элементов
- `ForEach(fn func(index int, value T))` - итерирует по всем элементам
- `ReverseForEach(fn func(index int, value T))` - итерирует в обратном порядке

## Циклические методы

- `GetNext(value T) (T, bool)` - возвращает следующий элемент после указанного
- `GetPrev(value T) (T, bool)` - возвращает предыдущий элемент перед указанным
- `RotateLeft(n int)` - поворачивает список влево на n позиций
- `RotateRight(n int)` - поворачивает список вправо на n позиций

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/circularlist"
)

func main() {
    // Создаем новый циклический список
    cl := circularlist.New[int]()
    
    // Добавляем элементы
    cl.Add(1)
    cl.Add(2)
    cl.Add(3)
    cl.Add(4)
    cl.Add(5)
    
    fmt.Printf("Size: %d\n", cl.Size()) // Size: 5
    
    // Получаем элементы
    if val, ok := cl.Get(0); ok {
        fmt.Printf("First element: %d\n", val) // First element: 1
    }
    
    // Итерируем по элементам
    cl.ForEach(func(index int, value int) {
        fmt.Printf("Index %d: %d\n", index, value)
    })
    // Output:
    // Index 0: 1
    // Index 1: 2
    // Index 2: 3
    // Index 3: 4
    // Index 4: 5
    
    // Циклическая навигация
    if next, ok := cl.GetNext(5); ok {
        fmt.Printf("Next after 5: %d\n", next) // Next after 5: 1 (circular)
    }
    if prev, ok := cl.GetPrev(1); ok {
        fmt.Printf("Prev before 1: %d\n", prev) // Prev before 1: 5 (circular)
    }
    
    // Вращение списка
    cl.RotateLeft(2) // Сдвигаем влево на 2 позиции
    // Теперь порядок: [3, 4, 5, 1, 2]
    
    // Удаляем элемент
    if cl.Remove(4) {
        fmt.Println("Removed element 4")
    }
    
    fmt.Printf("Final size: %d\n", cl.Size()) // Final size: 4
}
```

## Применение

- **Циклические алгоритмы**: планирование задач, алгоритмы Round-Robin
- **Игровые разработки**: циклические меню, очереди игроков
- **Алгоритмы обхода**: обработка элементов в циклическом порядке
- **Буферы**: кольцевые буферы с произвольным доступом
- **Графические интерфейсы**: циклические списки выбора

## Реализация

CircularList реализован как двусвязный циклический список, где каждый узел содержит:

- `Value` - значение элемента
- `next` - ссылка на следующий узел
- `prev` - ссылка на предыдущий узел

Список поддерживает эффективные операции вставки и удаления в любом месте за счет двусвязности, а цикличность позволяет легко перемещаться от последнего элемента к первому и наоборот.

## Производительность

- **Память**: O(n) где n - количество элементов
- **Add**: O(1) для добавления в конец
- **AddAt**: O(min(i, n-i)) где i - индекс вставки
- **Get**: O(min(i, n-i)) где i - индекс доступа
- **Remove**: O(min(i, n-i)) где i - индекс удаления
- **Contains**: O(n)
- **Вращение**: O(min(n, k)) где k - величина вращения

## Особенности поведения

- **Цикличность**: `GetNext` последнего элемента возвращает первый, `GetPrev` первого элемента возвращает последний
- **Индексация**: элементы индексируются с 0, как в обычном списке
- **Потокобезопасность**: все операции блокируют всю структуру данных, обеспечивая согласованность
- **Вращение**: изменяет логический порядок элементов без перемещения в памяти