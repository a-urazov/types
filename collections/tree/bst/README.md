# Binary Search Tree (BST)

Пакет `bst` предоставляет реализацию двоичного дерева поиска. BST - это структура данных, где каждый узел имеет не более двух потомков (левое и правое поддеревья), и значение в каждом узле больше всех значений в его левом поддереве и меньше всех значений в его правом поддереве.

## Основные методы

- `New[T]() *Tree[T]` - создает новое пустое дерево поиска
- `Insert(value T)` - вставляет значение в дерево
- `Search(value T) bool` - ищет значение в дереве
- `Delete(value T) bool` - удаляет значение из дерева
- `InOrder(fn func(T)) ` - выполняет обход дерева в порядке (левое, корень, правое)
- `PreOrder(fn func(T))` - выполняет предварительный обход (корень, левое, правое)
- `PostOrder(fn func(T))` - выполняет последующий обход (левое, правое, корень)
- `FindMin() (T, bool)` - находит минимальное значение
- `FindMax() (T, bool)` - находит максимальное значение

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/tree/bst"
)

func main() {
    tree := bst.New[int]()
    
    tree.Insert(5)
    tree.Insert(3)
    tree.Insert(7)
    tree.Insert(2)
    tree.Insert(4)
    tree.Insert(6)
    tree.Insert(8)
    
    // Инорядный обход (отсортирует в порядке возрастания)
    tree.InOrder(func(val int) {
        fmt.Print(val, " ") // Output: 2 3 4 5 6 7 8
    })
    
    if tree.Search(4) {
        fmt.Println("\n4 found!")
    }
}
```

## Особенности

- **Упорядоченное хранение**: элементы хранятся в отсортированном порядке
- **Быстрый поиск**: O(log n) в среднем случае, O(n) в худшем (несбалансированное дерево)
- **Инорядный обход**: дает элементы в отсортированном порядке

## Производительность

| Операция | Среднее случай | Худший случай |
|----------|---|---|
| Поиск | O(log n) | O(n) |
| Вставка | O(log n) | O(n) |
| Удаление | O(log n) | O(n) |

## Применение

- Поиск и хранение упорядоченных данных
- Реализация приоритетных очередей
- Поиск предшественника/преемника
- Поиск диапазона значений
- Сортировка данных
