# FenwickTree

Пакет `fenwicktree` предоставляет реализацию дерева Фенвика (Fenwick Tree), также известного как Binary Indexed Tree (BIT). Это структура данных, которая позволяет эффективно вычислять префиксные суммы и обновлять элементы в массиве за логарифмическое время.

## Особенности

- **Эффективные префиксные суммы**: O(log n) для вычисления суммы от начала до любого индекса
- **Быстрые точечные обновления**: O(log n) для добавления значения к элементу
- **Экономия памяти**: использует массив размером n+1, что более компактно, чем дерево отрезков
- **Потокобезопасность**: все операции защищены мьютексом для безопасной работы в многопоточной среде
- **Поддержка только целых чисел**: текущая реализация работает с `int`

## Основные методы

- `New(size int) *FenwickTree` - создает новое дерево Фенвика заданного размера
- `FromSlice(data []int) *FenwickTree` - создает дерево Фенвика из среза данных
- `Add(index, value int)` - добавляет значение к элементу по индексу
- `Query(index int)` - возвращает сумму элементов от 0 до `index` (включительно)
- `QueryRange(left, right int)` - возвращает сумму элементов в диапазоне [left, right]
- `Get(index int) int` - получает значение элемента по индексу (O(log n))
- `Set(index, value int)` - устанавливает новое значение для элемента по индексу
- `Size() int` - возвращает количество элементов
- `IsEmpty() bool` - возвращает true если дерево пусто (все элементы равны 0)
- `Clear()` - сбрасывает все элементы в 0
- `Resize(newSize int)` - изменяет размер дерева
- `ToSlice() []int` - возвращает срез текущих значений (O(n log n))
- `ForEach(fn func(index, value int))` - итерирует по всем элементам (O(n log n))

## Пример использования

```go
package main

import (
    "fmt"
    "types/collections/fenwicktree"
)

func main() {
    // Создаем дерево Фенвика из среза
    data := []int{1, 3, 5, 7, 9, 11}
    ft := fenwicktree.FromSlice(data)
    
    // Вычисляем префиксную сумму до индекса 3 (1+3+5+7)
    if sum := ft.Query(3); sum != 16 {
        fmt.Printf("Expected sum 16, got %d\n", sum)
    }
    
    // Вычисляем сумму на диапазоне [1, 4] (3+5+7+9)
    if sum := ft.QueryRange(1, 4); sum != 24 {
        fmt.Printf("Expected sum 24, got %d\n", sum)
    }
    
    // Добавляем 5 к элементу с индексом 2
    ft.Add(2, 5) // data becomes [1, 3, 10, 7, 9, 11]
    
    // Проверяем обновленные суммы
    if sum := ft.Query(3); sum != 21 { // 1+3+10+7
        fmt.Printf("New sum up to index 3: %d\n", sum)
    }
    
    // Устанавливаем новое значение
    ft.Set(0, 100)
    if val := ft.Get(0); val != 100 {
        fmt.Printf("Expected value 100, got %d\n", val)
    }
}
```

## Применение

- **Динамические префиксные суммы**: основной сценарий использования
- **Обработка массивов**: быстрые запросы на диапазонах и обновления
- **Статистика**: вычисление кумулятивных частот
- **Соревновательное программирование**: задачи, требующие эффективных операций с префиксными суммами
- **Финансовый анализ**: анализ временных рядов

## Реализация

Дерево Фенвика использует битовую магию для представления иерархической структуры в плоском массиве. Каждый узел в дереве отвечает за сумму в определенном диапазоне, и эти диапазоны эффективно комбинируются для вычисления префиксных сумм.

- **`Add(index, value)`**: обновляет все узлы, которые "отвечают" за данный индекс
- **`Query(index)`**: суммирует значения всех узлов, которые "влияют" на данный индекс

## Производительность

- **Память**: O(n)
- **Построение**: O(n log n)
- **Add**: O(log n)
- **Query**: O(log n)
- **QueryRange**: O(log n)
- **Get/Set**: O(log n)
- **ToSlice/ForEach**: O(n log n)

## Сравнение с деревом отрезков

| Характеристика | Дерево Фенвика | Дерево отрезков |
|---|---|---|
| **Память** | `n+1` | `~4n` |
| **Реализация** | Проще | Сложнее |
| **Гибкость** | Ограничено ассоциативными операциями (сумма) | Поддерживает любые ассоциативные операции (min, max, product) |
| **Производительность** | Немного быстрее из-за меньших констант | Немного медленнее |

Дерево Фенвика является отличной альтернативой дереву отрезков для задач, связанных с префиксными суммами, благодаря своей простоте и эффективности.